
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>main</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-11-26"><meta name="DC.source" content="main.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">1. Preprocessing of the PV sequence data downloaded from NCBI</a></li><li><a href="#7">2. Inferring the model representing the prevalence landscape of vp1 using ACE</a></li><li><a href="#11">3. Statistical validation of the inferred model</a></li><li><a href="#12">4. Analysis of local peaks in the vp1 prevalence landscape</a></li><li><a href="#20">5. In silico predicted energy vs in vitro replicative fitness measurements</a></li><li><a href="#23">6. Comparison with other standard methods</a></li><li><a href="#28">7. Comparison of vp1 landscape with those of HIV proteins (p24 and gp160)</a></li></ul></div><pre class="codeinput">clear <span class="string">all</span>;close <span class="string">all</span>;clc

addpath <span class="string">data</span>
addpath <span class="string">functions</span>
addpath <span class="string">tree_dendroscope_codes</span>
addpath <span class="string">clustering</span>

run <span class="string">startup.m</span>

set(0,<span class="string">'DefaultAxesFontName'</span>,<span class="string">'Arial'</span>)
set(0,<span class="string">'DefaultTextFontName'</span>,<span class="string">'Arial'</span>)
set(0,<span class="string">'DefaultAxesFontSize'</span>,10)
set(0,<span class="string">'DefaultTextFontSize'</span>,10)

run_scripts = 0;
<span class="comment">%1 = yes, run the scripts. Note that this would take long time...</span>
<span class="comment">%0 = no, use saved data.</span>
</pre><h2 id="2">1. Preprocessing of the PV sequence data downloaded from NCBI</h2><pre class="codeinput"><span class="comment">%Sequences downloaded from NCBI with search details "poliovirus"[Organism] are processed to filter the sequences belonging</span>
<span class="comment">%to each serotype. The number of sequences for each seroptype are computed and FASTA files are made for each serotype.</span>

inputFile = <span class="string">'Polio_ncbi_ns7776.fasta'</span>;
preprocessing_seqs_PV(inputFile);
</pre><img vspace="5" hspace="5" src="main_01.png" alt=""> <p>Statistics of the PV sequence data</p><pre class="codeinput">PV1_FastaFile = <span class="string">'Human_poliovirus1.fasta'</span>;
[msa_vp1, header_vp1] = stats_seqs_PV1(PV1_FastaFile);
</pre><img vspace="5" hspace="5" src="main_02.png" alt=""> <p>Obtaining the accession number of each sequence from the header of vp1</p><pre class="codeinput"><span class="keyword">for</span> kk = 1:length(header_vp1)
    indx_pipe = find(header_vp1{kk}==<span class="string">'|'</span>);
    accession_number{kk} = header_vp1{kk}(indx_pipe(3)+1:indx_pipe(4)-3);
<span class="keyword">end</span>
</pre><p>Using the accession number of each sequence to obtain information from the NCBI database, which is missing in the header</p><pre class="codeinput"><span class="keyword">if</span> run_scripts == 1
    [title,journal,country,year_vp1] = <span class="keyword">...</span>
        extract_info_from_accession_number_protein(accession_number);
<span class="keyword">else</span>
    load <span class="string">title_papers_vp1</span>
    load <span class="string">journal_vp1</span>
    load <span class="string">country_vp1</span>
    load <span class="string">year_vp1</span>
<span class="keyword">end</span>
</pre><p>Performing PCA of similarity matrix to distinguish between vp1 sequences that are wild-type and vaccine-derived poliovirus (VDPV)</p><pre class="codeinput">[msa_vp1_wt,seqs_wt] = analysis_similarity_matrix(msa_vp1);

msa = msa_vp1_wt;
[Nseq,Npos] = size(msa);
save <span class="string">msa_vp1_wt</span> <span class="string">msa</span> <span class="comment">%saving the wild-type vp1 MSA</span>
</pre><img vspace="5" hspace="5" src="main_03.png" alt=""> <h2 id="7">2. Inferring the model representing the prevalence landscape of vp1 using ACE</h2><pre class="codeinput"><span class="comment">% Code for running ACE is freely available at &lt;https://github.com/johnbarton/ACE&gt;.</span>
</pre><p>ACE input: Single and double mutant probabilities in the MSA</p><pre class="codeinput"><span class="comment">% Generating extended binary Potts MSA</span>

entropy = 0.9;
protein = <span class="string">'vp1'</span>;

[msa,msa_aa_ex,phi_curr,phi_cumulative,cross_prod,mutant_order,true_indices,<span class="keyword">...</span>
    total_length, protein_length_aa, diff_amino_site_length_RawMSA, bin_matrix] <span class="keyword">...</span>
    = generate_msa_binary_potts(entropy,<span class="string">'msa_vp1_wt.mat'</span>,protein);

save <span class="string">data_vp1</span> <span class="comment">%Saving data (to be used later)</span>

[ns,ls] = size(msa); <span class="comment">%original</span>
[ns_ex,ls_ex] = size(msa_aa_ex); <span class="comment">%extended binary</span>

fprintf(<span class="string">'-----------------------------------------------------------------------------------\n'</span>)
fprintf(<span class="string">'Length of amino acid MSA = %d\n'</span>,Npos)
fprintf(<span class="string">'Length of amino acid MSA (after removing 100%% conserved sites) = %d\n'</span>,ls)
fprintf(<span class="string">'Length of corresponding binary extended Potts MSA = %d\n'</span>,ls_ex)
fprintf(<span class="string">'-----------------------------------------------------------------------------------\n'</span>)

<span class="comment">% Saving the single and double mutant probabilities in the MSA in a format acceptable for ACE</span>

delete <span class="string">correlations_ACE_vp1.p</span>
save_correlations_ACE(msa_aa_ex,phi_curr,phi_cumulative,protein)
</pre><pre class="codeoutput">-----------------------------------------------------------------------------------
Length of amino acid MSA = 302
Length of amino acid MSA (after removing 100% conserved sites) = 163
Length of corresponding binary extended Potts MSA = 208
-----------------------------------------------------------------------------------
</pre><img vspace="5" hspace="5" src="main_04.png" alt=""> <p>ACE output: Maximum entropy model parameters (fields and couplings)</p><pre class="codeinput"><span class="comment">% Use the p file obtained in the previous step, which comprises the correlations, as input to ACE algo. The output</span>
<span class="comment">% "vp1-learn.j" consists of the model parameters. We save this text file in excel format and construct a model-paramters</span>
<span class="comment">% matrix "H" which consists of inferred fields on its diagonal and inferred couplings on the upper triangular matrix.</span>

H = ConstructHmatrix_couplings(<span class="string">'vp1-learn.xlsx'</span>,ls,phi_curr,phi_cumulative);
</pre><p>Generating samples from the inferred model using a Markov Chain Monte Carlo (MCMC) method</p><pre class="codeinput"><span class="comment">% ACE can generate samples from the predicted model using MCMC method.</span>
<span class="comment">% Three outputs:</span>
<span class="comment">%       1. vp1-sampler.p: the single and double mutants observed in the generated MCMC samples</span>
<span class="comment">%       2. vp1-mutdist-sampler.comp: the probability of mutations per sequence in the generated MCMC samples</span>
<span class="comment">%       3. vp1-sampler-msa.p: MCMC samples generated using the inferred model (20000)</span>
</pre><h2 id="11">3. Statistical validation of the inferred model</h2><pre class="codeinput"><span class="comment">% Comparison of model and MSA statistics</span>

<span class="comment">% Single and double mutant probability in the MSA</span>
freqs_data = <span class="string">'vp1-data.xlsx'</span>; <span class="comment">%Excel version of "correlations_ACE_vp1.p" which was the input given to ACE</span>
<span class="comment">% Single and double mutant probability in the generated MCMC samples</span>
freqs_sampler = <span class="string">'vp1-sampler.xlsx'</span>; <span class="comment">%Excel version of "vp1-sampler.p" obtained as an output from ACE</span>

<span class="comment">% Probability of mutations per sequences in the MSA, saved in "generate_msa_binary_potts.m"</span>
mutdist_data = <span class="string">'vp1-mutdist-data.xlsx'</span>;
<span class="comment">% Probability of mutations per sequences in the generated MCMC samples</span>
mutdist_sampler = <span class="string">'vp1-mutdist-sampler.xlsx'</span>; <span class="comment">%Excel version of "vp1-mutdist-sampler.comp" obtained as an output from ACE</span>

<span class="comment">% For triple mutant probability in the MSA and the MCMC samples</span>
input_configurations_sampler = <span class="string">'vp1-sampler-msa.xlsx'</span>; <span class="comment">%Excel version of "vp1-sampler-msa.p" obtained as an output from ACE</span>
input_data_file = <span class="string">'data_vp1.mat'</span>; <span class="comment">%Data saved after generating the binary extended Potts model</span>

<span class="keyword">if</span> run_scripts == 1
    [p2_data,p2_sampler] = getting_two_point_connected_correlations(input_configurations_sampler,input_data_file);
    [p3_data,p3_sampler] = getting_three_point_connected_correlations(input_configurations_sampler,input_data_file);
<span class="keyword">else</span>
    load <span class="string">cov_vp1_2pt.mat</span>
    load <span class="string">cov_vp1_3pt.mat</span>
<span class="keyword">end</span>

<span class="comment">% Plots</span>
color = blue;
markersize = 4;

plot_one_and_two_point_correlations(ls,freqs_data,freqs_sampler,color,markersize)
plot_three_point_correlations(p3_data,p3_sampler,color,markersize)
plot_mutdist(mutdist_data,mutdist_sampler,color)
plot_pmf_most_prev_aminoacids(input_configurations_sampler,input_data_file)

plot_two_point_connected_correlations(p3_data,p3_sampler,color,markersize)
plot_three_point_connected_correlations(p3_data,p3_sampler,color,markersize)
</pre><img vspace="5" hspace="5" src="main_05.png" alt=""> <img vspace="5" hspace="5" src="main_06.png" alt=""> <img vspace="5" hspace="5" src="main_07.png" alt=""> <img vspace="5" hspace="5" src="main_08.png" alt=""> <img vspace="5" hspace="5" src="main_09.png" alt=""> <img vspace="5" hspace="5" src="main_10.png" alt=""> <img vspace="5" hspace="5" src="main_11.png" alt=""> <img vspace="5" hspace="5" src="main_12.png" alt=""> <h2 id="12">4. Analysis of local peaks in the vp1 prevalence landscape</h2><p>Determining the number of local peaks in the vp1 prevalence landscape</p><pre class="codeinput"><span class="keyword">if</span> run_scripts == 1
    determine_local_peaks(input_data_file,H)
<span class="keyword">else</span>
    load <span class="string">vp1_peaks</span>
<span class="keyword">end</span>

<span class="comment">%Plotting peak rank vs fraction of sequences in each peak</span>
data_peaks = <span class="string">'vp1_peaks'</span>;
plot_rank_peaks(data_peaks,H,input_data_file)

<span class="comment">%data related to peaks and their rank is saved in 'vp1_peaks_rank.mat'</span>
</pre><pre class="codeoutput">no_of_peak_seqs_vp1 =
    25
</pre><img vspace="5" hspace="5" src="main_13.png" alt=""> <p>Antigenic analysis of local peaks</p><pre class="codeinput">data_peaks_rank = <span class="string">'vp1_peaks_rank.mat'</span>;
peaks_antigenic_analysis(input_data_file,data_peaks_rank)
</pre><img vspace="5" hspace="5" src="main_14.png" alt=""> <img vspace="5" hspace="5" src="main_15.png" alt=""> <p>Geographical analysis of local peaks</p><pre class="codeinput">data_country_vp1 = <span class="string">'country_vp1.mat'</span>; <span class="comment">%information obtained from NCBI using the accession number as shown in Section 1.</span>
data_year_vp1 = <span class="string">'year_vp1.mat'</span>; <span class="comment">%information obtained from NCBI using the accession number as shown in Section 1.</span>
dist_geographical_peaks = peaks_geographical_analysis(input_data_file,data_peaks_rank,data_country_vp1,data_year_vp1);
<span class="comment">% The information provided in "dist_geographical_peaks" can be used to make a figure similar to Figure 3a (reproduced</span>
<span class="comment">% below for completeness).</span>
</pre><p><img vspace="5" hspace="5" src="map.png" alt=""> </p><p>Temporal analysis of local peaks</p><pre class="codeinput">peaks_temporal_analysis(input_data_file,data_peaks_rank,data_country_vp1,data_year_vp1);
</pre><img vspace="5" hspace="5" src="main_16.png" alt=""> <p>Zero-temperature Monte Carlo computational method to identify pathways between the local peaks</p><pre class="codeinput"><span class="keyword">if</span> run_scripts == 1
    Pathways_peaks = ZeroTempMCSim(input_data_file,data_peaks_rank);
<span class="keyword">else</span>
    load <span class="string">Pathways_peaks</span>
<span class="keyword">end</span>
<span class="comment">% "Pathways_peaks" is a 10x10 matrix showing the pathways connecting the top 10 most-populous peaks in the landscape. We</span>
<span class="comment">% plotted these pathways in Figure 4 (reproduced below for completeness) using the web-version of the Circos plot available</span>
<span class="comment">% at http://mkweb.bcgsc.ca/tableviewer/visualize/</span>
</pre><p><img vspace="5" hspace="5" src="circos_valleys_mcmc_thinUp_natcom.png" alt=""> </p><h2 id="20">5. In silico predicted energy vs in vitro replicative fitness measurements</h2><p>Peak 1 only</p><pre class="codeinput"><span class="comment">%Data saved after generating the binary extended Potts model for sequences in peak 1 only</span>
data_peak1 = <span class="string">'data_vp1_peak1'</span>;
<span class="comment">%Model parameters for sequences in peak 1 only</span>
H_peak1 = <span class="string">'H_vp1_peak1'</span>;

energy_vs_fitness_peak1(data_peak1,H_peak1)
</pre><img vspace="5" hspace="5" src="main_17.png" alt=""> <p>All except peak 1</p><pre class="codeinput"><span class="comment">%Data saved after generating the binary extended Potts model for sequences from all peaks except peak 1</span>
data_nonpeak1 = <span class="string">'data_vp1_nonpeak1.mat'</span>;
<span class="comment">%Model parameters for model including sequences from all peaks except peak 1</span>
H_nonpeak1 = <span class="string">'H_vp1_nonpeak1.mat'</span>;

energy_vs_fitness_nonpeak1(data_nonpeak1,H_nonpeak1)
</pre><pre class="codeoutput">rho =
   -0.5084
pval =
    0.0034
</pre><img vspace="5" hspace="5" src="main_18.png" alt=""> <h2 id="23">6. Comparison with other standard methods</h2><p>Phylogenetic tree</p><pre class="codeinput"><span class="comment">% PASTA v1.6.4, software freely available at https://github.com/smirarab/pasta, was used to construct a maximum-likelihood</span>
<span class="comment">% phylogenetic tree (Figure 5A) using the VP1 fasta file "vp1_v5_header_peak_acc_country_year.fasta". The header of this FASTA</span>
<span class="comment">% file is modified to incorporate peak information which is beneficial in coloring the sequences.</span>
<span class="comment">% The modified format is as follows:</span>

<span class="comment">% |Peak associated with the sequence|Accession number of the sequence|Sampling country of the sequence |Sampling year of the sequence|</span>

<span class="comment">% PASTA automatically selects the appropriate parameters for tree estimation based on the provided sequence data. The</span>
<span class="comment">% resulting phylogenetic tree is stored in "*.tre" file.</span>

<span class="comment">% Dendroscope v3.5.9, software freely available at http://dendroscope.org/,  was used for visualizing this constructred</span>
<span class="comment">% phylogenetic tree and re-rooting it with the earliest available sequence (accession number: AF528768). The rectangular</span>
<span class="comment">% and circular phylogram layouts available in Dendroscope were used for visualization. The sequences (that form the leaves</span>
<span class="comment">% of the tree; reproduced below for completeness) were colored using the code "code_coloring_seqs_in_tree_wrt_peaks.txt".</span>
<span class="comment">% In Dendroscope, after loading the "*.tre" file and re-rooting it, click Window&gt;Command Input, paste the code in the</span>
<span class="comment">% opened window, and click "Apply".</span>
</pre><p><img vspace="5" hspace="5" src="tree.png" alt=""> </p><p>Standard clustering methods</p><pre class="codeinput"><span class="comment">%K-means clustering</span>
<span class="keyword">if</span> run_scripts == 1
    Custering_output_vs_peaks_Kmeans = clustering_Kmeans(input_data_file,data_peaks_rank);
<span class="keyword">else</span>
    load <span class="string">Custering_output_vs_peaks_Kmeans.mat</span>
<span class="keyword">end</span>

<span class="comment">%Hierarchical clustering</span>
<span class="keyword">if</span> run_scripts == 1
    Custering_output_vs_peaks_hierarchical = clustering_hierarchical(input_data_file,data_peaks_rank);
<span class="keyword">else</span>
    load <span class="string">Custering_output_vs_peaks_hierarchical.mat</span>
<span class="keyword">end</span>

<span class="comment">%Spectral clustering</span>
<span class="keyword">if</span> run_scripts == 1
    Custering_output_vs_peaks_spectralClustering = clustering_spectral(input_data_file,data_peaks_rank);
<span class="keyword">else</span>
    load <span class="string">Custering_output_vs_peaks_spectralClustering.mat</span>
<span class="keyword">end</span>

<span class="comment">% The output "Custering_output_vs_peaks_xyz" is a matrix with element (i,j) representing percetage of peak i sequences</span>
<span class="comment">% in the cluster j formed using the clustering method xyz.</span>
<span class="comment">% Each script above saves a csv file that comprises the data in a format which can be used to plot heatmaps in Python</span>
<span class="comment">% as shown in Figure 6b (reproduced below for completeness). The Python code "heatmap_annotation_xyz.py" to construct</span>
<span class="comment">% the heatmaps for method xyz is also provided in this package. This code is written in Python 2.7 and requires the</span>
<span class="comment">% seaborn package available at &lt;https://seaborn.pydata.org/&gt;.</span>
</pre><p><img vspace="5" hspace="5" src="clustering_methods.png" alt=""> </p><h2 id="28">7. Comparison of vp1 landscape with those of HIV proteins (p24 and gp160)</h2><p>Autocorrelation</p><pre class="codeinput"><span class="comment">% Computing autocorrelation of each protein landscape</span>

<span class="comment">%Data of each protein landscape</span>
data_peak1 = <span class="string">'data_vp1_peak1'</span>;
data_p24 = <span class="string">'data_p24'</span>;
data_gp160 = <span class="string">'data_gp160'</span>;
<span class="comment">%Model parameters of each protein landscape</span>
H_peak1 = <span class="string">'H_vp1_peak1'</span>;
H_p24 = <span class="string">'H_p24'</span>;
H_gp160 = <span class="string">'H_gp160'</span>;

<span class="keyword">if</span> run_scripts == 1
    <span class="comment">%D = 5</span>
    ak_vp1_D5 = compute_autocorrelation_landscape(data_peak1, H_peak1, 5);
    ak_p24_D5 = compute_autocorrelation_landscape(data_p24, H_p24, 5);
    ak_gp160_D5 = compute_autocorrelation_landscape(data_gp160, H_gp160, 5);
    <span class="comment">%D = 30</span>
    ak_vp1_D30 = compute_autocorrelation_landscape(data_peak1, H_peak1, 30);
    ak_p24_D30 = compute_autocorrelation_landscape(data_p24, H_p24, 30);
    ak_gp160_D30 = compute_autocorrelation_landscape(data_gp160, H_gp160, 30);
<span class="keyword">else</span>
   load <span class="string">autocorrelation_vp1_peak1_D5.mat</span>
   load <span class="string">autocorrelation_vp1_peak1_D30.mat</span>
   load <span class="string">autocorrelation_p24_D5.mat</span>
   load <span class="string">autocorrelation_p24_D30.mat</span>
   load <span class="string">autocorrelation_gp160_D5.mat</span>
   load <span class="string">autocorrelation_gp160_D30.mat</span>
<span class="keyword">end</span>

<span class="comment">% Plot</span>
plot_autocorrelation_comparison(ak_vp1_D5,ak_vp1_D30,ak_p24_D5,ak_p24_D30,ak_gp160_D5,ak_gp160_D30)
</pre><img vspace="5" hspace="5" src="main_19.png" alt=""> <p>Neutrality</p><pre class="codeinput"><span class="comment">% Computing neutrality of each protein landscape</span>
data_peak1 = <span class="string">'data_vp1_peak1'</span>;
data_p24 = <span class="string">'data_p24'</span>;
data_gp160 = <span class="string">'data_gp160'</span>;
<span class="keyword">if</span> run_scripts == 1
    <span class="comment">%L = 500</span>
    mean_hamming_distance_max_vp1_L500 = compute_neutrality_landscape(data_peak1,500);
    mean_hamming_distance_max_p24_L500 = compute_neutrality_landscape(data_p24,500);
    mean_hamming_distance_max_gp160_L500 = compute_neutrality_landscape(data_gp160,500);
    <span class="comment">%L = 1000</span>
    mean_hamming_distance_max_vp1_L1000 = compute_neutrality_landscape(data_peak1,1000);
    mean_hamming_distance_max_p24_L1000 = compute_neutrality_landscape(data_p24,1000);
    mean_hamming_distance_max_gp160_L1000 = compute_neutrality_landscape(data_gp160,1000);
<span class="keyword">else</span>
   load <span class="string">mean_hamming_distance_max_vp1_peak1_L500.mat</span>
   load <span class="string">mean_hamming_distance_max_vp1_peak1_L1000.mat</span>
   load <span class="string">mean_hamming_distance_max_p24_L500.mat</span>
   load <span class="string">mean_hamming_distance_max_p24_L1000.mat</span>
   load <span class="string">mean_hamming_distance_max_gp160_L500.mat</span>
   load <span class="string">mean_hamming_distance_max_gp160_L1000.mat</span>
<span class="keyword">end</span>

<span class="comment">% Plot</span>
plot_neutrality_comparison(mean_hamming_distance_max_vp1_L500, mean_hamming_distance_max_vp1_L1000, <span class="keyword">...</span>
    mean_hamming_distance_max_p24_L500, mean_hamming_distance_max_p24_L1000, <span class="keyword">...</span>
    mean_hamming_distance_max_epsilon_gp160_L500, mean_hamming_distance_max_epsilon_gp160_L1000)
</pre><img vspace="5" hspace="5" src="main_20.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####

clear all;close all;clc

addpath data
addpath functions
addpath tree_dendroscope_codes
addpath clustering

run startup.m

set(0,'DefaultAxesFontName','Arial')
set(0,'DefaultTextFontName','Arial')
set(0,'DefaultAxesFontSize',10)
set(0,'DefaultTextFontSize',10)

run_scripts = 0;
%1 = yes, run the scripts. Note that this would take long time...
%0 = no, use saved data.

%% 1. Preprocessing of the PV sequence data downloaded from NCBI

%Sequences downloaded from NCBI with search details "poliovirus"[Organism] are processed to filter the sequences belonging 
%to each serotype. The number of sequences for each seroptype are computed and FASTA files are made for each serotype.

inputFile = 'Polio_ncbi_ns7776.fasta';
preprocessing_seqs_PV(inputFile);

%%    
% Statistics of the PV sequence data

PV1_FastaFile = 'Human_poliovirus1.fasta';
[msa_vp1, header_vp1] = stats_seqs_PV1(PV1_FastaFile);


%%
% Obtaining the accession number of each sequence from the header of vp1

for kk = 1:length(header_vp1)
    indx_pipe = find(header_vp1{kk}=='|');
    accession_number{kk} = header_vp1{kk}(indx_pipe(3)+1:indx_pipe(4)-3);
end

%%
% Using the accession number of each sequence to obtain information from the NCBI database, which is missing in the header

if run_scripts == 1
    [title,journal,country,year_vp1] = ...
        extract_info_from_accession_number_protein(accession_number);
else
    load title_papers_vp1
    load journal_vp1
    load country_vp1
    load year_vp1
end

%%
% Performing PCA of similarity matrix to distinguish between vp1 sequences that are wild-type and vaccine-derived poliovirus (VDPV)

[msa_vp1_wt,seqs_wt] = analysis_similarity_matrix(msa_vp1);

msa = msa_vp1_wt;
[Nseq,Npos] = size(msa);
save msa_vp1_wt msa %saving the wild-type vp1 MSA

%% 2. Inferring the model representing the prevalence landscape of vp1 using ACE

% Code for running ACE is freely available at <https://github.com/johnbarton/ACE>. 

%% 
% ACE input: Single and double mutant probabilities in the MSA

% Generating extended binary Potts MSA

entropy = 0.9;
protein = 'vp1';

[msa,msa_aa_ex,phi_curr,phi_cumulative,cross_prod,mutant_order,true_indices,...
    total_length, protein_length_aa, diff_amino_site_length_RawMSA, bin_matrix] ...
    = generate_msa_binary_potts(entropy,'msa_vp1_wt.mat',protein);

save data_vp1 %Saving data (to be used later)

[ns,ls] = size(msa); %original
[ns_ex,ls_ex] = size(msa_aa_ex); %extended binary

fprintf('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-\n')
fprintf('Length of amino acid MSA = %d\n',Npos)
fprintf('Length of amino acid MSA (after removing 100%% conserved sites) = %d\n',ls)
fprintf('Length of corresponding binary extended Potts MSA = %d\n',ls_ex)
fprintf('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-\n')

% Saving the single and double mutant probabilities in the MSA in a format acceptable for ACE

delete correlations_ACE_vp1.p
save_correlations_ACE(msa_aa_ex,phi_curr,phi_cumulative,protein)

%% 
% ACE output: Maximum entropy model parameters (fields and couplings)

% Use the p file obtained in the previous step, which comprises the correlations, as input to ACE algo. The output 
% "vp1-learn.j" consists of the model parameters. We save this text file in excel format and construct a model-paramters 
% matrix "H" which consists of inferred fields on its diagonal and inferred couplings on the upper triangular matrix.

H = ConstructHmatrix_couplings('vp1-learn.xlsx',ls,phi_curr,phi_cumulative);

%%
% Generating samples from the inferred model using a Markov Chain Monte Carlo (MCMC) method

% ACE can generate samples from the predicted model using MCMC method.
% Three outputs:
%       1. vp1-sampler.p: the single and double mutants observed in the generated MCMC samples
%       2. vp1-mutdist-sampler.comp: the probability of mutations per sequence in the generated MCMC samples
%       3. vp1-sampler-msa.p: MCMC samples generated using the inferred model (20000)

%% 3. Statistical validation of the inferred model 

% Comparison of model and MSA statistics

% Single and double mutant probability in the MSA
freqs_data = 'vp1-data.xlsx'; %Excel version of "correlations_ACE_vp1.p" which was the input given to ACE
% Single and double mutant probability in the generated MCMC samples
freqs_sampler = 'vp1-sampler.xlsx'; %Excel version of "vp1-sampler.p" obtained as an output from ACE

% Probability of mutations per sequences in the MSA, saved in "generate_msa_binary_potts.m"
mutdist_data = 'vp1-mutdist-data.xlsx'; 
% Probability of mutations per sequences in the generated MCMC samples
mutdist_sampler = 'vp1-mutdist-sampler.xlsx'; %Excel version of "vp1-mutdist-sampler.comp" obtained as an output from ACE

% For triple mutant probability in the MSA and the MCMC samples
input_configurations_sampler = 'vp1-sampler-msa.xlsx'; %Excel version of "vp1-sampler-msa.p" obtained as an output from ACE
input_data_file = 'data_vp1.mat'; %Data saved after generating the binary extended Potts model

if run_scripts == 1
    [p2_data,p2_sampler] = getting_two_point_connected_correlations(input_configurations_sampler,input_data_file);
    [p3_data,p3_sampler] = getting_three_point_connected_correlations(input_configurations_sampler,input_data_file);
else 
    load cov_vp1_2pt.mat
    load cov_vp1_3pt.mat
end

% Plots
color = blue;
markersize = 4;

plot_one_and_two_point_correlations(ls,freqs_data,freqs_sampler,color,markersize)
plot_three_point_correlations(p3_data,p3_sampler,color,markersize)
plot_mutdist(mutdist_data,mutdist_sampler,color)
plot_pmf_most_prev_aminoacids(input_configurations_sampler,input_data_file)

plot_two_point_connected_correlations(p3_data,p3_sampler,color,markersize)
plot_three_point_connected_correlations(p3_data,p3_sampler,color,markersize)

%% 4. Analysis of local peaks in the vp1 prevalence landscape

%%
% Determining the number of local peaks in the vp1 prevalence landscape

if run_scripts == 1
    determine_local_peaks(input_data_file,H)
else
    load vp1_peaks
end

%Plotting peak rank vs fraction of sequences in each peak
data_peaks = 'vp1_peaks';
plot_rank_peaks(data_peaks,H,input_data_file) 

%data related to peaks and their rank is saved in 'vp1_peaks_rank.mat'

%%
% Antigenic analysis of local peaks
data_peaks_rank = 'vp1_peaks_rank.mat';
peaks_antigenic_analysis(input_data_file,data_peaks_rank)

%%
% Geographical analysis of local peaks

data_country_vp1 = 'country_vp1.mat'; %information obtained from NCBI using the accession number as shown in Section 1.
data_year_vp1 = 'year_vp1.mat'; %information obtained from NCBI using the accession number as shown in Section 1.
dist_geographical_peaks = peaks_geographical_analysis(input_data_file,data_peaks_rank,data_country_vp1,data_year_vp1);
% The information provided in "dist_geographical_peaks" can be used to make a figure similar to Figure 3a (reproduced 
% below for completeness).

%%
% 
% <<map.png>>
% 

%%
% Temporal analysis of local peaks

peaks_temporal_analysis(input_data_file,data_peaks_rank,data_country_vp1,data_year_vp1);

%%
% Zero-temperature Monte Carlo computational method to identify pathways between the local peaks

if run_scripts == 1
    Pathways_peaks = ZeroTempMCSim(input_data_file,data_peaks_rank);
else 
    load Pathways_peaks
end
% "Pathways_peaks" is a 10x10 matrix showing the pathways connecting the top 10 most-populous peaks in the landscape. We
% plotted these pathways in Figure 4 (reproduced below for completeness) using the web-version of the Circos plot available 
% at http://mkweb.bcgsc.ca/tableviewer/visualize/

%%
% 
% <<circos_valleys_mcmc_thinUp_natcom.png>>
% 

%% 5. In silico predicted energy vs in vitro replicative fitness measurements

%%
% Peak 1 only

%Data saved after generating the binary extended Potts model for sequences in peak 1 only
data_peak1 = 'data_vp1_peak1'; 
%Model parameters for sequences in peak 1 only
H_peak1 = 'H_vp1_peak1'; 

energy_vs_fitness_peak1(data_peak1,H_peak1)

%%
% All except peak 1

%Data saved after generating the binary extended Potts model for sequences from all peaks except peak 1
data_nonpeak1 = 'data_vp1_nonpeak1.mat'; 
%Model parameters for model including sequences from all peaks except peak 1
H_nonpeak1 = 'H_vp1_nonpeak1.mat'; 

energy_vs_fitness_nonpeak1(data_nonpeak1,H_nonpeak1)

%% 6. Comparison with other standard methods

%% 
% Phylogenetic tree

% PASTA v1.6.4, software freely available at https://github.com/smirarab/pasta, was used to construct a maximum-likelihood 
% phylogenetic tree (Figure 5A) using the VP1 fasta file "vp1_v5_header_peak_acc_country_year.fasta". The header of this FASTA
% file is modified to incorporate peak information which is beneficial in coloring the sequences. 
% The modified format is as follows:

% |Peak associated with the sequence|Accession number of the sequence|Sampling country of the sequence |Sampling year of the sequence|

% PASTA automatically selects the appropriate parameters for tree estimation based on the provided sequence data. The 
% resulting phylogenetic tree is stored in "*.tre" file.

% Dendroscope v3.5.9, software freely available at http://dendroscope.org/,  was used for visualizing this constructred 
% phylogenetic tree and re-rooting it with the earliest available sequence (accession number: AF528768). The rectangular 
% and circular phylogram layouts available in Dendroscope were used for visualization. The sequences (that form the leaves 
% of the tree; reproduced below for completeness) were colored using the code "code_coloring_seqs_in_tree_wrt_peaks.txt". 
% In Dendroscope, after loading the "*.tre" file and re-rooting it, click Window>Command Input, paste the code in the 
% opened window, and click "Apply".

%%
% 
% <<tree.png>>
% 

%%
% Standard clustering methods

%K-means clustering
if run_scripts == 1
    Custering_output_vs_peaks_Kmeans = clustering_Kmeans(input_data_file,data_peaks_rank);
else 
    load Custering_output_vs_peaks_Kmeans.mat
end

%Hierarchical clustering
if run_scripts == 1
    Custering_output_vs_peaks_hierarchical = clustering_hierarchical(input_data_file,data_peaks_rank);
else 
    load Custering_output_vs_peaks_hierarchical.mat
end

%Spectral clustering
if run_scripts == 1
    Custering_output_vs_peaks_spectralClustering = clustering_spectral(input_data_file,data_peaks_rank);
else 
    load Custering_output_vs_peaks_spectralClustering.mat
end

% The output "Custering_output_vs_peaks_xyz" is a matrix with element (i,j) representing percetage of peak i sequences 
% in the cluster j formed using the clustering method xyz.
% Each script above saves a csv file that comprises the data in a format which can be used to plot heatmaps in Python 
% as shown in Figure 6b (reproduced below for completeness). The Python code "heatmap_annotation_xyz.py" to construct 
% the heatmaps for method xyz is also provided in this package. This code is written in Python 2.7 and requires the 
% seaborn package available at <https://seaborn.pydata.org/>.

%%
% 
% <<clustering_methods.png>>
% 

%% 7. Comparison of vp1 landscape with those of HIV proteins (p24 and gp160)

%%
% Autocorrelation

% Computing autocorrelation of each protein landscape

%Data of each protein landscape
data_peak1 = 'data_vp1_peak1'; 
data_p24 = 'data_p24'; 
data_gp160 = 'data_gp160'; 
%Model parameters of each protein landscape
H_peak1 = 'H_vp1_peak1'; 
H_p24 = 'H_p24';
H_gp160 = 'H_gp160';

if run_scripts == 1
    %D = 5
    ak_vp1_D5 = compute_autocorrelation_landscape(data_peak1, H_peak1, 5);
    ak_p24_D5 = compute_autocorrelation_landscape(data_p24, H_p24, 5);
    ak_gp160_D5 = compute_autocorrelation_landscape(data_gp160, H_gp160, 5);
    %D = 30
    ak_vp1_D30 = compute_autocorrelation_landscape(data_peak1, H_peak1, 30);
    ak_p24_D30 = compute_autocorrelation_landscape(data_p24, H_p24, 30);
    ak_gp160_D30 = compute_autocorrelation_landscape(data_gp160, H_gp160, 30);
else
   load autocorrelation_vp1_peak1_D5.mat
   load autocorrelation_vp1_peak1_D30.mat
   load autocorrelation_p24_D5.mat
   load autocorrelation_p24_D30.mat
   load autocorrelation_gp160_D5.mat
   load autocorrelation_gp160_D30.mat
end

% Plot
plot_autocorrelation_comparison(ak_vp1_D5,ak_vp1_D30,ak_p24_D5,ak_p24_D30,ak_gp160_D5,ak_gp160_D30)
    

%%
% Neutrality

% Computing neutrality of each protein landscape
data_peak1 = 'data_vp1_peak1'; 
data_p24 = 'data_p24'; 
data_gp160 = 'data_gp160'; 
if run_scripts == 1
    %L = 500
    mean_hamming_distance_max_vp1_L500 = compute_neutrality_landscape(data_peak1,500);
    mean_hamming_distance_max_p24_L500 = compute_neutrality_landscape(data_p24,500);
    mean_hamming_distance_max_gp160_L500 = compute_neutrality_landscape(data_gp160,500);
    %L = 1000
    mean_hamming_distance_max_vp1_L1000 = compute_neutrality_landscape(data_peak1,1000);    
    mean_hamming_distance_max_p24_L1000 = compute_neutrality_landscape(data_p24,1000);    
    mean_hamming_distance_max_gp160_L1000 = compute_neutrality_landscape(data_gp160,1000);    
else
   load mean_hamming_distance_max_vp1_peak1_L500.mat
   load mean_hamming_distance_max_vp1_peak1_L1000.mat
   load mean_hamming_distance_max_p24_L500.mat
   load mean_hamming_distance_max_p24_L1000.mat
   load mean_hamming_distance_max_gp160_L500.mat
   load mean_hamming_distance_max_gp160_L1000.mat
end

% Plot
plot_neutrality_comparison(mean_hamming_distance_max_vp1_L500, mean_hamming_distance_max_vp1_L1000, ...
    mean_hamming_distance_max_p24_L500, mean_hamming_distance_max_p24_L1000, ...
    mean_hamming_distance_max_epsilon_gp160_L500, mean_hamming_distance_max_epsilon_gp160_L1000)


##### SOURCE END #####
--></body></html>